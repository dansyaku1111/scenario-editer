import {
  _get,
  _slicedToArray
} from "./chunk-GQ5PGQ4R.js";
import {
  BaseAreaPlugin
} from "./chunk-5X4R47EN.js";
import {
  NodeEditor,
  Scope,
  _assertThisInitialized,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _defineProperty,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _typeof,
  getUID,
  require_regenerator
} from "./chunk-SX2PHM4M.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/rete-connection-plugin/rete-connection-plugin.esm.js
var import_regenerator = __toESM(require_regenerator());
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function createPseudoconnection(extra) {
  var element = null;
  var id = null;
  function unmount(areaPlugin) {
    if (id) {
      areaPlugin.removeConnectionView(id);
    }
    element = null;
    id = null;
  }
  function mount(areaPlugin) {
    unmount(areaPlugin);
    id = "pseudo_".concat(getUID());
  }
  return {
    isMounted: function isMounted() {
      return Boolean(id);
    },
    mount,
    // eslint-disable-next-line complexity
    render: function render(areaPlugin, _ref, data) {
      var x = _ref.x, y = _ref.y;
      var isOutput = data.side === "output";
      var pointer = {
        x: x + (isOutput ? -3 : 3),
        y
      };
      if (!id)
        throw new Error("pseudo connection id wasn't generated");
      var payload = isOutput ? _objectSpread({
        id,
        source: data.nodeId,
        sourceOutput: data.key,
        target: "",
        targetInput: ""
      }, extra || {}) : _objectSpread({
        id,
        target: data.nodeId,
        targetInput: data.key,
        source: "",
        sourceOutput: ""
      }, extra || {});
      if (!element) {
        var view = areaPlugin.addConnectionView(payload);
        element = view.element;
      }
      if (!element)
        return;
      areaPlugin.emit({
        type: "render",
        data: _objectSpread({
          element,
          type: "connection",
          payload
        }, isOutput ? {
          end: pointer
        } : {
          start: pointer
        })
      });
    },
    unmount
  };
}
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function findSocket(socketsCache, elements) {
  var _iterator = _createForOfIteratorHelper$1(elements), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var element = _step.value;
      var found = socketsCache.get(element);
      if (found) {
        return found;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
var Flow = _createClass(function Flow2() {
  _classCallCheck(this, Flow2);
});
var State = function() {
  function State2() {
    _classCallCheck(this, State2);
  }
  _createClass(State2, [{
    key: "setContext",
    value: function setContext(context) {
      this.context = context;
    }
  }]);
  return State2;
}();
function getSourceTarget(initial, socket) {
  var forward = initial.side === "output" && socket.side === "input";
  var backward = initial.side === "input" && socket.side === "output";
  var _ref = forward ? [initial, socket] : backward ? [socket, initial] : [], _ref2 = _slicedToArray(_ref, 2), source = _ref2[0], target = _ref2[1];
  if (source && target)
    return [source, target];
}
function canMakeConnection(initial, socket) {
  return Boolean(getSourceTarget(initial, socket));
}
function makeConnection(initial, socket, context) {
  var _ref3 = getSourceTarget(initial, socket) || [null, null], _ref4 = _slicedToArray(_ref3, 2), source = _ref4[0], target = _ref4[1];
  if (source && target) {
    context.editor.addConnection({
      id: getUID(),
      source: source.nodeId,
      sourceOutput: source.key,
      target: target.nodeId,
      targetInput: target.key
    });
    return true;
  }
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Picked$1 = function(_State) {
  _inherits(Picked2, _State);
  var _super = _createSuper$2(Picked2);
  function Picked2(initial, params) {
    var _this;
    _classCallCheck(this, Picked2);
    _this = _super.call(this);
    _this.initial = initial;
    _this.params = params;
    return _this;
  }
  _createClass(Picked2, [{
    key: "pick",
    value: function() {
      var _pick = _asyncToGenerator(import_regenerator.default.mark(function _callee(_ref, context) {
        var socket;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                socket = _ref.socket;
                if (this.params.makeConnection(this.initial, socket, context)) {
                  this.drop(context, socket, true);
                } else if (!this.params.pickByClick) {
                  this.drop(context, socket);
                }
              case 2:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function pick(_x, _x2) {
        return _pick.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "drop",
    value: function drop(context) {
      var socket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var created = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.initial) {
        context.scope.emit({
          type: "connectiondrop",
          data: {
            initial: this.initial,
            socket,
            created
          }
        });
      }
      this.context.switchTo(new Idle$1(this.params));
    }
  }]);
  return Picked2;
}(State);
var Idle$1 = function(_State2) {
  _inherits(Idle2, _State2);
  var _super2 = _createSuper$2(Idle2);
  function Idle2(params) {
    var _this2;
    _classCallCheck(this, Idle2);
    _this2 = _super2.call(this);
    _this2.params = params;
    return _this2;
  }
  _createClass(Idle2, [{
    key: "pick",
    value: function() {
      var _pick2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_ref2, context) {
        var socket, event;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                socket = _ref2.socket, event = _ref2.event;
                if (!(event === "down")) {
                  _context2.next = 9;
                  break;
                }
                _context2.next = 4;
                return context.scope.emit({
                  type: "connectionpick",
                  data: {
                    socket
                  }
                });
              case 4:
                if (!_context2.sent) {
                  _context2.next = 8;
                  break;
                }
                this.context.switchTo(new Picked$1(socket, this.params));
                _context2.next = 9;
                break;
              case 8:
                this.drop(context);
              case 9:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function pick(_x3, _x4) {
        return _pick2.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "drop",
    value: function drop(context) {
      var socket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var created = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.initial) {
        context.scope.emit({
          type: "connectiondrop",
          data: {
            initial: this.initial,
            socket,
            created
          }
        });
      }
      delete this.initial;
    }
  }]);
  return Idle2;
}(State);
var BidirectFlow = function() {
  function BidirectFlow2(params) {
    _classCallCheck(this, BidirectFlow2);
    var pickByClick = Boolean(params === null || params === void 0 ? void 0 : params.pickByClick);
    var makeConnection$1 = (params === null || params === void 0 ? void 0 : params.makeConnection) || makeConnection;
    this.switchTo(new Idle$1({
      pickByClick,
      makeConnection: makeConnection$1
    }));
  }
  _createClass(BidirectFlow2, [{
    key: "pick",
    value: function() {
      var _pick3 = _asyncToGenerator(import_regenerator.default.mark(function _callee3(params, context) {
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.currentState.pick(params, context);
              case 2:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function pick(_x5, _x6) {
        return _pick3.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "getPickedSocket",
    value: function getPickedSocket() {
      return this.currentState.initial;
    }
  }, {
    key: "drop",
    value: function drop(context) {
      this.currentState.drop(context);
    }
  }, {
    key: "switchTo",
    value: function switchTo(state) {
      state.setContext(this);
      this.currentState = state;
    }
  }]);
  return BidirectFlow2;
}();
function findPort(socket, editor) {
  var node = editor.getNode(socket.nodeId);
  if (!node)
    throw new Error("cannot find node");
  var list = socket.side === "input" ? node.inputs : node.outputs;
  return list[socket.key];
}
function findConnections(socket, editor) {
  var nodeId = socket.nodeId, side = socket.side, key = socket.key;
  return editor.getConnections().filter(function(connection) {
    if (side === "input") {
      return connection.target === nodeId && connection.targetInput === key;
    }
    if (side === "output") {
      return connection.source === nodeId && connection.sourceOutput === key;
    }
  });
}
function syncConnections(sockets, editor) {
  var connections = sockets.map(function(socket) {
    var port = findPort(socket, editor);
    var multiple = port === null || port === void 0 ? void 0 : port.multipleConnections;
    if (multiple)
      return [];
    return findConnections(socket, editor);
  }).flat();
  return {
    commit: function commit() {
      var uniqueIds = Array.from(new Set(connections.map(function(_ref) {
        var id = _ref.id;
        return id;
      })));
      uniqueIds.forEach(function(id) {
        return editor.removeConnection(id);
      });
    }
  };
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Picked = function(_State) {
  _inherits(Picked2, _State);
  var _super = _createSuper$1(Picked2);
  function Picked2(initial, params) {
    var _this;
    _classCallCheck(this, Picked2);
    _this = _super.call(this);
    _this.initial = initial;
    _this.params = params;
    return _this;
  }
  _createClass(Picked2, [{
    key: "pick",
    value: function() {
      var _pick = _asyncToGenerator(import_regenerator.default.mark(function _callee(_ref, context) {
        var socket, created;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                socket = _ref.socket;
                if (this.params.canMakeConnection(this.initial, socket)) {
                  syncConnections([this.initial, socket], context.editor).commit();
                  created = this.params.makeConnection(this.initial, socket, context);
                  this.drop(context, created ? socket : null, created);
                }
              case 2:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function pick(_x, _x2) {
        return _pick.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "drop",
    value: function drop(context) {
      var socket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var created = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.initial) {
        context.scope.emit({
          type: "connectiondrop",
          data: {
            initial: this.initial,
            socket,
            created
          }
        });
      }
      this.context.switchTo(new Idle(this.params));
    }
  }]);
  return Picked2;
}(State);
var PickedExisting = function(_State2) {
  _inherits(PickedExisting2, _State2);
  var _super2 = _createSuper$1(PickedExisting2);
  function PickedExisting2(connection, params, context) {
    var _this2;
    _classCallCheck(this, PickedExisting2);
    _this2 = _super2.call(this);
    _this2.connection = connection;
    _this2.params = params;
    var outputSocket = Array.from(context.socketsCache.values()).find(function(data) {
      return data.nodeId === _this2.connection.source && data.side === "output" && data.key === _this2.connection.sourceOutput;
    });
    if (!outputSocket)
      throw new Error("cannot find output socket");
    _this2.outputSocket = outputSocket;
    return _this2;
  }
  _createClass(PickedExisting2, [{
    key: "init",
    value: function() {
      var _init = _asyncToGenerator(import_regenerator.default.mark(function _callee2(context) {
        var _this3 = this;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1)
            switch (_context2.prev = _context2.next) {
              case 0:
                context.scope.emit({
                  type: "connectionpick",
                  data: {
                    socket: this.outputSocket
                  }
                }).then(function(response) {
                  if (response) {
                    context.editor.removeConnection(_this3.connection.id);
                    _this3.initial = _this3.outputSocket;
                  } else {
                    _this3.drop(context);
                  }
                });
              case 1:
              case "end":
                return _context2.stop();
            }
        }, _callee2, this);
      }));
      function init(_x3) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "pick",
    value: function() {
      var _pick2 = _asyncToGenerator(import_regenerator.default.mark(function _callee3(_ref2, context) {
        var socket, event, created, _created;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                socket = _ref2.socket, event = _ref2.event;
                if (this.initial && !(socket.side === "input" && this.connection.target === socket.nodeId && this.connection.targetInput === socket.key)) {
                  if (this.params.canMakeConnection(this.initial, socket)) {
                    syncConnections([this.initial, socket], context.editor).commit();
                    created = this.params.makeConnection(this.initial, socket, context);
                    this.drop(context, created ? socket : null, created);
                  }
                } else if (event === "down") {
                  if (this.initial) {
                    syncConnections([this.initial, socket], context.editor).commit();
                    _created = this.params.makeConnection(this.initial, socket, context);
                    this.drop(context, _created ? socket : null, _created);
                  }
                }
              case 2:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function pick(_x4, _x5) {
        return _pick2.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "drop",
    value: function drop(context) {
      var socket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var created = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.initial) {
        context.scope.emit({
          type: "connectiondrop",
          data: {
            initial: this.initial,
            socket,
            created
          }
        });
      }
      this.context.switchTo(new Idle(this.params));
    }
  }]);
  return PickedExisting2;
}(State);
var Idle = function(_State3) {
  _inherits(Idle2, _State3);
  var _super3 = _createSuper$1(Idle2);
  function Idle2(params) {
    var _this4;
    _classCallCheck(this, Idle2);
    _this4 = _super3.call(this);
    _this4.params = params;
    return _this4;
  }
  _createClass(Idle2, [{
    key: "pick",
    value: function() {
      var _pick3 = _asyncToGenerator(import_regenerator.default.mark(function _callee4(_ref3, context) {
        var socket, event, _connection, state;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                socket = _ref3.socket, event = _ref3.event;
                if (!(event !== "down")) {
                  _context4.next = 3;
                  break;
                }
                return _context4.abrupt("return");
              case 3:
                if (!(socket.side === "input")) {
                  _context4.next = 11;
                  break;
                }
                _connection = context.editor.getConnections().find(function(item) {
                  return item.target === socket.nodeId && item.targetInput === socket.key;
                });
                if (!_connection) {
                  _context4.next = 11;
                  break;
                }
                state = new PickedExisting(_connection, this.params, context);
                _context4.next = 9;
                return state.init(context);
              case 9:
                this.context.switchTo(state);
                return _context4.abrupt("return");
              case 11:
                _context4.next = 13;
                return context.scope.emit({
                  type: "connectionpick",
                  data: {
                    socket
                  }
                });
              case 13:
                if (!_context4.sent) {
                  _context4.next = 17;
                  break;
                }
                this.context.switchTo(new Picked(socket, this.params));
                _context4.next = 18;
                break;
              case 17:
                this.drop(context);
              case 18:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this);
      }));
      function pick(_x6, _x7) {
        return _pick3.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "drop",
    value: function drop(context) {
      var socket = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var created = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      if (this.initial) {
        context.scope.emit({
          type: "connectiondrop",
          data: {
            initial: this.initial,
            socket,
            created
          }
        });
      }
      delete this.initial;
    }
  }]);
  return Idle2;
}(State);
var ClassicFlow = function() {
  function ClassicFlow2(params) {
    _classCallCheck(this, ClassicFlow2);
    var canMakeConnection$1 = (params === null || params === void 0 ? void 0 : params.canMakeConnection) || canMakeConnection;
    var makeConnection$1 = (params === null || params === void 0 ? void 0 : params.makeConnection) || makeConnection;
    this.switchTo(new Idle({
      canMakeConnection: canMakeConnection$1,
      makeConnection: makeConnection$1
    }));
  }
  _createClass(ClassicFlow2, [{
    key: "pick",
    value: function() {
      var _pick4 = _asyncToGenerator(import_regenerator.default.mark(function _callee5(params, context) {
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.currentState.pick(params, context);
              case 2:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function pick(_x8, _x9) {
        return _pick4.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "getPickedSocket",
    value: function getPickedSocket() {
      return this.currentState.initial;
    }
  }, {
    key: "switchTo",
    value: function switchTo(state) {
      state.setContext(this);
      this.currentState = state;
    }
  }, {
    key: "drop",
    value: function drop(context) {
      this.currentState.drop(context);
    }
  }]);
  return ClassicFlow2;
}();
function setup() {
  return function() {
    return new ClassicFlow();
  };
}
var classic = Object.freeze({
  __proto__: null,
  setup
});
var index = Object.freeze({
  __proto__: null,
  classic
});
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ConnectionPlugin = function(_Scope) {
  _inherits(ConnectionPlugin2, _Scope);
  var _super = _createSuper(ConnectionPlugin2);
  function ConnectionPlugin2() {
    var _this;
    _classCallCheck(this, ConnectionPlugin2);
    _this = _super.call(this, "connection");
    _defineProperty(_assertThisInitialized(_this), "presets", []);
    _defineProperty(_assertThisInitialized(_this), "currentFlow", null);
    _defineProperty(_assertThisInitialized(_this), "preudoconnection", createPseudoconnection({
      isPseudo: true
    }));
    _defineProperty(_assertThisInitialized(_this), "socketsCache", /* @__PURE__ */ new Map());
    return _this;
  }
  _createClass(ConnectionPlugin2, [{
    key: "addPreset",
    value: function addPreset(preset) {
      this.presets.push(preset);
    }
  }, {
    key: "findPreset",
    value: function findPreset(data) {
      var _iterator = _createForOfIteratorHelper(this.presets), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var preset = _step.value;
          var flow = preset(data);
          if (flow)
            return flow;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return null;
    }
  }, {
    key: "update",
    value: function update() {
      if (!this.currentFlow)
        return;
      var socket = this.currentFlow.getPickedSocket();
      if (socket) {
        this.preudoconnection.render(this.areaPlugin, this.areaPlugin.area.pointer, socket);
      }
    }
    /**
     * Drop pseudo-connection if exists
     * @emits connectiondrop
     */
  }, {
    key: "drop",
    value: function drop() {
      var flowContext = {
        editor: this.editor,
        scope: this,
        socketsCache: this.socketsCache
      };
      if (this.currentFlow) {
        this.currentFlow.drop(flowContext);
        this.preudoconnection.unmount(this.areaPlugin);
        this.currentFlow = null;
      }
    }
    // eslint-disable-next-line max-statements
  }, {
    key: "pick",
    value: function() {
      var _pick = _asyncToGenerator(import_regenerator.default.mark(function _callee(event, type) {
        var flowContext, pointedElements, pickedSocket;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                flowContext = {
                  editor: this.editor,
                  scope: this,
                  socketsCache: this.socketsCache
                };
                pointedElements = document.elementsFromPoint(event.clientX, event.clientY);
                pickedSocket = findSocket(this.socketsCache, pointedElements);
                event.preventDefault();
                event.stopPropagation();
                if (!pickedSocket) {
                  _context.next = 13;
                  break;
                }
                this.currentFlow = this.currentFlow || this.findPreset(pickedSocket);
                if (!this.currentFlow) {
                  _context.next = 11;
                  break;
                }
                _context.next = 10;
                return this.currentFlow.pick({
                  socket: pickedSocket,
                  event: type
                }, flowContext);
              case 10:
                this.preudoconnection.mount(this.areaPlugin);
              case 11:
                _context.next = 14;
                break;
              case 13:
                if (this.currentFlow) {
                  this.currentFlow.drop(flowContext);
                }
              case 14:
                if (this.currentFlow && !this.currentFlow.getPickedSocket()) {
                  this.preudoconnection.unmount(this.areaPlugin);
                  this.currentFlow = null;
                }
                this.update();
              case 16:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function pick(_x, _x2) {
        return _pick.apply(this, arguments);
      }
      return pick;
    }()
  }, {
    key: "setParent",
    value: function setParent(scope) {
      var _this2 = this;
      _get(_getPrototypeOf(ConnectionPlugin2.prototype), "setParent", this).call(this, scope);
      this.areaPlugin = this.parentScope(BaseAreaPlugin);
      this.editor = this.areaPlugin.parentScope(NodeEditor);
      var pointerdownSocket = function pointerdownSocket2(e) {
        _this2.pick(e, "down");
      };
      this.addPipe(function(context) {
        if (!context || _typeof(context) !== "object" || !("type" in context))
          return context;
        if (context.type === "pointermove") {
          _this2.update();
        } else if (context.type === "pointerup") {
          _this2.pick(context.data.event, "up");
        } else if (context.type === "render") {
          if (context.data.type === "socket") {
            var element = context.data.element;
            element.addEventListener("pointerdown", pointerdownSocket);
            _this2.socketsCache.set(element, context.data);
          }
        } else if (context.type === "unmount") {
          var _element = context.data.element;
          _element.removeEventListener("pointerdown", pointerdownSocket);
          _this2.socketsCache["delete"](_element);
        }
        return context;
      });
    }
  }]);
  return ConnectionPlugin2;
}(Scope);
export {
  BidirectFlow,
  ClassicFlow,
  ConnectionPlugin,
  Flow,
  index as Presets,
  State,
  canMakeConnection,
  createPseudoconnection,
  getSourceTarget,
  makeConnection
};
/*! Bundled license information:

rete-connection-plugin/rete-connection-plugin.esm.js:
  (*!
  * rete-connection-plugin v2.0.0
  * (c) 2024 Vitaliy Stoliarov
  * Released under the MIT license.
  * *)
*/
//# sourceMappingURL=rete-connection-plugin.js.map
